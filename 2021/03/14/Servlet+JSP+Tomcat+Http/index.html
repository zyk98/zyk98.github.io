<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="互联网通信流程介绍四。涉及技术【老旧】1.控制浏览器行为技术： HTML ，CSS ,JavaScript 2.控制硬盘上数据库行为技术：MySql数据库服务器管理使用（SQL重点），JDBC规范 3.控制服务端Java行为技术： Http服务器，Servlet，JSP 4.互联网通信流程开发规则： MVC 五。什么是互联网通信两台计算机通过网络实现文件共享行为，就是【互联网通信】 六。互联网通信">
<meta property="og:type" content="article">
<meta property="og:title" content="ZYK的博客">
<meta property="og:url" content="http://example.com/2021/03/14/Servlet+JSP+Tomcat+Http/index.html">
<meta property="og:site_name" content="ZYK的博客">
<meta property="og:description" content="互联网通信流程介绍四。涉及技术【老旧】1.控制浏览器行为技术： HTML ，CSS ,JavaScript 2.控制硬盘上数据库行为技术：MySql数据库服务器管理使用（SQL重点），JDBC规范 3.控制服务端Java行为技术： Http服务器，Servlet，JSP 4.互联网通信流程开发规则： MVC 五。什么是互联网通信两台计算机通过网络实现文件共享行为，就是【互联网通信】 六。互联网通信">
<meta property="og:locale">
<meta property="article:published_time" content="2021-03-14T03:59:44.843Z">
<meta property="article:modified_time" content="2021-03-13T18:31:37.214Z">
<meta property="article:author" content="ZYK">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"right","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/2021/03/14/Servlet+JSP+Tomcat+Http/"/>





  <title> | ZYK的博客</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZYK的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/14/Servlet+JSP+Tomcat+Http/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYK的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-14T11:59:44+08:00">
                2021-03-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="互联网通信流程介绍"><a href="#互联网通信流程介绍" class="headerlink" title="互联网通信流程介绍"></a>互联网通信流程介绍</h1><h5 id="四。涉及技术【老旧】"><a href="#四。涉及技术【老旧】" class="headerlink" title="四。涉及技术【老旧】"></a>四。涉及技术【老旧】</h5><p>1.控制浏览器行为技术： HTML ，CSS ,JavaScript</p>
<p>2.控制硬盘上数据库行为技术：MySql数据库服务器管理使用（SQL重点），JDBC规范</p>
<p>3.控制服务端Java行为技术： Http服务器，Servlet，JSP</p>
<p>4.互联网通信流程开发规则： MVC</p>
<h5 id="五。什么是互联网通信"><a href="#五。什么是互联网通信" class="headerlink" title="五。什么是互联网通信"></a>五。什么是互联网通信</h5><p>两台计算机通过网络实现文件共享行为，就是【互联网通信】</p>
<h5 id="六。互联网通信过程角色划分"><a href="#六。互联网通信过程角色划分" class="headerlink" title="六。互联网通信过程角色划分"></a>六。互联网通信过程角色划分</h5><p>1.客户端计算机：用于发送请求，来索要资源文件的计算机</p>
<p>2.服务端计算机：用于接收请求，并提供对应的资源文件计算机</p>
<h5 id="七。互联网通信模型"><a href="#七。互联网通信模型" class="headerlink" title="七。互联网通信模型"></a>七。互联网通信模型</h5><p>1.C/S通信模型：企业办公领域相对应用较少</p>
<p>C：client software;客户端软件</p>
<p>​    1）客户端软件专门安装在客户端计算机上</p>
<p>​    2）帮助客户端计算机向指定服务端计算机发送请求，索要资源文件</p>
<p>​    3）帮助客户端计算机将服务端计算机发送回来【二进制数据】解析为【文字，数字，图片，视频，命令】</p>
<p>S：server software;服务器软件</p>
<p>​    1)服务器软件专门安装在服务端计算机上</p>
<p>​    2)服务器软件用于接收来自于特定的客户端软件发送请求</p>
<p>​    3)服务器软件在接收到请求之后自动的在服务端计算机上定位被访问的资源文件</p>
<p>​    4)服务器软件自动的将定位的文件内容解析为【二进制数据】通过网络发送回发起请求的客户端软件上</p>
<p>适用场景：C/S通信模型普遍用于个人娱乐市场，比如【微信，淘宝/京东，视频（优酷/B站），大型网络游戏(魔兽/英雄联盟)】</p>
<p>优点:<br>        1.安全性较高</p>
<p>​        2.有效降低服务端计算机工作压力</p>
<p>缺点：<br>        1.增加客户获得服务的成本</p>
<p>​        2.更新较为繁琐</p>
<p>2.B/S通信模型：</p>
<p>B：browser,浏览器</p>
<p>​    1）浏览器安装在客户端计算机软件</p>
<p>​    2）可以向任意服务器发送请求，索要资源文件</p>
<p>​    3）可以将服务器返回的【二进制数据】解析为【文字，数字，图片，视频，命令】</p>
<p>S：server software 服务器软件</p>
<p>​    1)服务器软件专门安装在服务端计算机上</p>
<p>​    2)可以接收任意浏览器发送请求</p>
<p>​    3)自动的在服务端计算机上定位被访问的资源文件</p>
<p>​    4)自动的将定位的资源文件内容以二进制形式发送回发起请求浏览器上</p>
<p>适用场景： 既适用于个人娱乐市场，又广泛适用于企业日常活动</p>
<p>优点：</p>
<p>​    1.不会增加用户获得服务的成本</p>
<p>​    2.几乎不需要更新浏览器</p>
<p>缺点：</p>
<p>​    1.几乎无法有效对服务端计算机资源文件进行保护</p>
<p>​    2.服务端计算机工作压力异常巨大—–》【B/S通信下高并发解决方案】</p>
<h5 id="八。共享资源文件："><a href="#八。共享资源文件：" class="headerlink" title="八。共享资源文件："></a>八。共享资源文件：</h5><p> 1.什么是共享资源文件:</p>
<p>可以通过网络进行传输的文件，都被称为共享资源文件</p>
<p>所有的文件内容都可以通过网络传输，所有文件都是共享资源文件</p>
<p> 2.Http服务器下对于共享资源文件分类</p>
<p>1）静态资源文件    </p>
<p>2）动态资源文件</p>
<p> 3.静态资源文件:</p>
<p>​     1) 如果文件内容是固定，这种文件被称为【静态资源文件】  (文档，图片，视频)</p>
<p>​     2) 如果文件存放不是内容而是命令，这些命令只能在浏览器编译与执行这种文件被称为【静态资源文件】（.html,.css,.js）</p>
<p> 4.动态资源文件:</p>
<p>​        如果文件存放命令，且命令不能在浏览器编译与执行；只能在服务端计算机编译执行，这样的文件被称为【动态资源文件】（.class）</p>
<p> 5.静态资源文件与动态资源文件调用区别</p>
<p>静态文件被索要时，Http服务器直接通过【输出流】将静态文件中内容或则命令以【二进制形式】推送给发起请求浏览器</p>
<p>动态文件被索要时，Http服务器需要创建当前class文件的实例对象,通过实例对象调用对应的方法处理用户请求，<br>通过【输出流】将运行结果以【二进制形式】推送给发起请求浏览器 </p>
<p>class Student{<br>    public int add(int num1,int num2){<br>        int sum = num1 + num2;<br>        return sum;<br>    }<br>}</p>
<p>Http服务器（自动）。new一个student，然后把传过来的结果存入，并调用对象输出<br>    Student stu = new Student();<br>    int 结果 = stu.add(10,20);<br>    out.print(结果)</p>
<h5 id="九。开发人员在互联网通信流程担负职责"><a href="#九。开发人员在互联网通信流程担负职责" class="headerlink" title="九。开发人员在互联网通信流程担负职责:"></a>九。开发人员在互联网通信流程担负职责:</h5><p>1.控制浏览器行为</p>
<p>2.开发动态资源文件来解决用户请求</p>
<h2 id="Http网络协议包"><a href="#Http网络协议包" class="headerlink" title="Http网络协议包"></a>Http网络协议包</h2><h5 id="一。网络协议包："><a href="#一。网络协议包：" class="headerlink" title="一。网络协议包："></a>一。网络协议包：</h5><p>1.在网络中传递信息都是以【二进制】形式存在的。</p>
<p>2.接收方【浏览器/服务器】在接收信息后，要做第一件事就是将【二进制数据】进行编译【文字，图片，视频，命令】</p>
<p>3.传递信息数据量往往比较巨大，导致接收方很难在一组连续二进制得到对应数据</p>
<p>比如 浏览器发送一个请求： <a target="_blank" rel="noopener" href="http://192.168.100.2:8080/index.html%EF%BC%8C%E8%BF%99%E4%B8%AA%E8%AF%B7%E6%B1%82%E4%BF%A1%E6%81%AF%E4%BB%A5%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%BD%A2%E5%BC%8F%E5%8F%91%E9%80%81">http://192.168.100.2:8080/index.html，这个请求信息以二进制形式发送</a> 01010101010110101010101101010，Http服务器很难从二进制数据得到相关信息</p>
<p>4.网络协议包一组有规律二进制数据，在这组数据存在了固定空间。每一个空间专门存放特定信息，这样接收方在接收网络协议包之后就可以到固定空间得到对应信息，网络协议包出现极大降低了接收方对接收二进制数据编译难度</p>
<p>【0000（ip地址）0000（端口号）0000（资源文件名）0000】</p>
<h5 id="二。常见网络协议："><a href="#二。常见网络协议：" class="headerlink" title="二。常见网络协议："></a>二。常见网络协议：</h5><p>1.FTP网络协议包</p>
<p>2.Http网络协议包</p>
<h5 id="三。Http网络协议包："><a href="#三。Http网络协议包：" class="headerlink" title="三。Http网络协议包："></a>三。Http网络协议包：</h5><p>在基于B/S结构下互联网通信过程中，所有在网络中传递信息都是保存在Http网络协议包</p>
<p>分类：</p>
<p>​      Http请求协议包</p>
<p>​      Http响应协议包</p>
<h5 id="四。Http请求协议包与Http响应协议包介绍"><a href="#四。Http请求协议包与Http响应协议包介绍" class="headerlink" title="四。Http请求协议包与Http响应协议包介绍:"></a>四。Http请求协议包与Http响应协议包介绍:</h5><p>1.Http请求协议包：</p>
<p>在浏览器准备发送请求时，负责创建一个Http请求协议包</p>
<p>浏览器将请求信息以二进制形式保存在Http请求协议包各个空间</p>
<p>由浏览器负责将Http请求协议包推送到指定服务端计算机</p>
<p>2.Http响应协议包：</p>
<p>Http服务器在定位到被访问的资源文件之后。</p>
<p>负责创建一个Http响应协议包，Http服务器将定位文件内容或则文件命令以</p>
<p>二进制形式写入到Http响应协议包各个空间，由Http服务器负责将Http响应协议包推送回发起请求的浏览器上。</p>
<h5 id="五。Http请求协议包内部空间：【背】"><a href="#五。Http请求协议包内部空间：【背】" class="headerlink" title="五。Http请求协议包内部空间：【背】"></a>五。Http请求协议包内部空间：【背】</h5><p>1.按照自上而下划分，分为4个空间</p>
<p>2.空间划分:</p>
<p>请求行：[</p>
<p>​            url:请求地址（<a target="_blank" rel="noopener" href="http://192.168.100.2:8080/index.html%EF%BC%89">http://192.168.100.2:8080/index.html）</a></p>
<p>​            method:请求方式（POST/GET）</p>
<p>]</p>
<p>请求头：[</p>
<p>​              请求参数信息【GET】</p>
<p>]</p>
<p>空白行：[</p>
<p>​                没有任何内容，起到隔离作用 </p>
<p>]</p>
<p>请求体：[</p>
<p>​               请求参数信息【POST】</p>
<p>]</p>
<h5 id="六。Http响应协议包内部结构-【背】"><a href="#六。Http响应协议包内部结构-【背】" class="headerlink" title="六。Http响应协议包内部结构 【背】"></a>六。Http响应协议包内部结构 【背】</h5><p>1.按照自上而下划分，分为4个空间</p>
<p>2.空间划分:</p>
<p>状态行：[</p>
<p>​              Http状态码     </p>
<p>]</p>
<p>响应头：[</p>
<p>​              content-type: 指定浏览器采用对应编译器对响应体二进制数据进行解析<br>]</p>
<p>空白行：[</p>
<p>​              没有任何内容，起到隔离作用<br>]</p>
<p>响应体：[</p>
<p>​    可能被访问静态资源文件内容</p>
<p>​    可能被访问的静态资源文件命令</p>
<p>​    可能被访问的动态资源文件运行结果</p>
<p>​                  **<em><strong>都是以二进制形式</strong></em><br>]</p>
<h1 id="Servlet：服务器端小程序-serv-let"><a href="#Servlet：服务器端小程序-serv-let" class="headerlink" title="Servlet：服务器端小程序 serv+let"></a>Servlet：服务器端小程序 serv+let</h1><h3 id="JavaSE和JavaEE？"><a href="#JavaSE和JavaEE？" class="headerlink" title="JavaSE和JavaEE？"></a>JavaSE和JavaEE？</h3><h5 id="1、什么是API？包括什么？"><a href="#1、什么是API？包括什么？" class="headerlink" title="1、什么是API？包括什么？"></a>1、什么是API？包括什么？</h5><p>​    API：应用程序编程接口</p>
<p>​    API包括：源码、字节码、帮助文档</p>
<h5 id="2、什么是JAVASE？"><a href="#2、什么是JAVASE？" class="headerlink" title="2、什么是JAVASE？"></a>2、什么是JAVASE？</h5><p>​    Java标准版本，SUN公司为java程序员提供的一套基础类库，这套基础类库包括：基础语法、面向对象、异常、IO、集合、反射、线程……JavaSE版本目前javase由Oracle维护</p>
<h5 id="3、JavaSE的源码、字节码、帮助文档在哪？"><a href="#3、JavaSE的源码、字节码、帮助文档在哪？" class="headerlink" title="3、JavaSE的源码、字节码、帮助文档在哪？"></a>3、JavaSE的源码、字节码、帮助文档在哪？</h5><p>​    -JAVA_HOME\src.zip    源码</p>
<p>​    -JRE_HOME\lib\rt.jar     字节码</p>
<p>​    -帮助文档</p>
<h5 id="4、什么是JAVAEE？"><a href="#4、什么是JAVAEE？" class="headerlink" title="4、什么是JAVAEE？"></a>4、什么是JAVAEE？</h5><p>​    java企业版。SUN公司为java程序员准备另一套庞大的类库，帮助程序员完成企业级项目开发。</p>
<h5 id="5、JAVAEE的版本号？"><a href="#5、JAVAEE的版本号？" class="headerlink" title="5、JAVAEE的版本号？"></a>5、JAVAEE的版本号？</h5><p>​    -目前我们所学习的JAVAEE版本号是JAVAEE5</p>
<p>​    -JAVAEE规范是一个比较大的规范，JAVAEE规范中包括13个子规范（每一个子规范下其实还有其它的子规范。）</p>
<p>​    -JAVAEE5规范下的子规范：</p>
<p>​        Servlet2.5</p>
<p>​        JDBC</p>
<p>​    -JAVAEE6规范下的子规范：</p>
<p>​        -Servlet3.0</p>
<p>​        -JDBC</p>
<p>​    -Tomcat服务器，其中Tomcat6实现了Servlet2.5规范，Tomcat7实现了Servlet3.0规范</p>
<p>​    我们使用的是Tomcat7</p>
<h3 id="Servlet："><a href="#Servlet：" class="headerlink" title="Servlet："></a>Servlet：</h3><h5 id="本质："><a href="#本质：" class="headerlink" title="本质："></a>本质：</h5><p>用户输入访问资源路径，然后Tomcat读取web.xml利用key去获得value，之后利用反射机制以value创建servlet对象，最后调用service方法即可。</p>
<h5 id="第一个带有Servlet的WebApp，FirstServletWebApp："><a href="#第一个带有Servlet的WebApp，FirstServletWebApp：" class="headerlink" title="第一个带有Servlet的WebApp，FirstServletWebApp："></a>第一个带有Servlet的WebApp，FirstServletWebApp：</h5><p>web.xml:</p>
<p>web.xml里面的url-pattern可以写多个</p>
<h5 id="将响应结果输出到浏览器中，PrintToBrowser："><a href="#将响应结果输出到浏览器中，PrintToBrowser：" class="headerlink" title="将响应结果输出到浏览器中，PrintToBrowser："></a>将响应结果输出到浏览器中，PrintToBrowser：</h5><h5 id="解决响应时中文乱码问题："><a href="#解决响应时中文乱码问题：" class="headerlink" title="解决响应时中文乱码问题："></a>解决响应时中文乱码问题：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br></pre></td></tr></table></figure>



<h5 id="Servlet对象生命周期"><a href="#Servlet对象生命周期" class="headerlink" title="Servlet对象生命周期"></a>Servlet对象生命周期</h5><p>1、什么是生命周期？</p>
<p>​            一个java对象从最初被创建到最终被销毁经历的所有过程</p>
<p>2、Servlet对象的生命周期是谁来管理的？程序员可以干涉吗？</p>
<p>​            Servlet对象的生命周期，javaweb程序员无权干涉。全部是由WEB容器来管理的</p>
<p>3、”默认情况下”，Servlet对象在WEB服务器启动阶段不会被实例化。</p>
<p>4、描述Servlet对象的生命周期：</p>
<p>​        1）用户在浏览器地址栏输入URL <a target="_blank" rel="noopener" href="http://localhost:8080/123">http://localhost:8080/123</a></p>
<p>​        2）web容器截取请求路径 /123</p>
<p>​        3）web容器在容器上下文中找请求路径/123对应的Servlet对象</p>
<p>​        4）若没有找到对应的Servlet对象</p>
<p>​                4.1）通过web.xml文件中相关的配置信息，得到请求路径/123对应的Servlet完整类名</p>
<p>​                4.2）通过反射机制，调用Servlet类的无参数构造方法完成Servlet对象的实例化</p>
<p>​                4.3）web容器调用Servlet对象的init方法初始化</p>
<p>​                4.4）web容器调用Servlet对象的service方法提供服务</p>
<p>​        5）若找到对应的Servlet对象</p>
<p>​                5.1）web容器直接调用Servlet对象的service方法提供服务</p>
<p>​        6）web容器关闭的时候/webapp重新部署的时候/该Servlet对象长时间没有用户再次访问的时候，web容器会将该Servlet对象销毁，在销毁对象之前，web容器会调用destroy方法完成销毁之前的准备</p>
<p>5、总结：</p>
<p>​    Servlet类的构造方法只执行一次；Servlet的init、destroy两个方法只执行一次；Servlet的service方法用户请求一次就执行一次</p>
<p>6、注意;</p>
<p>​    init方法执行的时候，Servlet对象已经被创建好了</p>
<p>​    destroy方法执行的时候，Servlet对象还没有被销毁</p>
<p>7、Servlet对象是单例，但是是伪单例。Tomcat服务器是多线程的，Servlet对象是在单实例多线程的环境下运行的。如果Servlet对象中有实例变量且涉及到修改操作，那么这个Servlet对象一定会存在线程安全问题，不建议在Servlet对象中使用实例变量，尽量使用局部变量</p>
<p>8、若希望在web服务器启动阶段实例化Servlet对象，需要在web.xml文件中操作<load-on-startup> 1</load-on-startup> ，这里的数字，从0到∞，优先级依次降低。</p>
<p>9、Servlet接口中的这些方法中编写什么代码？什么时候使用这些方法？</p>
<p>1）无参数构造方法</p>
<p>2）init方法</p>
<p>​        以上两个方法执行时间几乎是相同的，执行次数都是一次，构造方法执行的时候对象正在创建，init方法执行的时候对象已经创建：若要求对象在创建时执行一段程序，则写在init方法中</p>
<p>​        为什么不建议将代码编写到构造函数中？</p>
<p>​        存在风险。当程序员编写有参构造方法的时候会导致无参构造不存在。</p>
<p>​        Serlvet中的init方法是SUN公司为javaweb程序员专门提供的一个初始化时刻， 若希望在初始化时刻执行一段程序，则编写到init方法中等待自动调用。</p>
<p>3）service方法</p>
<p>​    这个方法是必然要重写的，因为在这个方法需要完成业务逻辑的处理，请求的处理以及完成响应。</p>
<p>​    而且这个方法的代码是最有价值的，也是最难写的</p>
<p>4）destroy方法</p>
<p>​    也是SUN公司为javaweb程序员提供的一个特殊的时刻，这个特殊的时刻被称为对象销毁时刻，若希望在销毁时刻执行一段特殊的代码，需要将这段代码编写到destroy方法中。</p>
<h5 id="UML（统一建模语言）：反应一个对象的生命周期"><a href="#UML（统一建模语言）：反应一个对象的生命周期" class="headerlink" title="UML（统一建模语言）：反应一个对象的生命周期"></a>UML（统一建模语言）：反应一个对象的生命周期</h5><p>1、什么是UML？</p>
<p>​    a）统一建模语言，在系统设计阶段由系统分析师使用的语言，使用这些图标语言体现设计思想。</p>
<p>​    b）后期程序员开发的依据就是这些设计图，属于软件工程学、与编程语言无关</p>
<p>2、UML图都有哪些？</p>
<p>​    a）类图：描述类的信息以及类和类之间的关系</p>
<p>​    b）时序图：描述一个程序的执行过程</p>
<p>​    c）用例图：站在系统用户的角度分析系统中存在哪些功能</p>
<p>​    d）状态图：描述一个对象的生命周期</p>
<h4 id="ServletConfig接口"><a href="#ServletConfig接口" class="headerlink" title="ServletConfig接口"></a>ServletConfig接口</h4><p>在 Servlet 接口的 init()方法中有一个参数 ServletConfig，这个参数类型是个接口，里面是一些 在 web.xml 中对当前 Servlet类的配置信息。Servlet 规范将Servlet 的配置信息全部封装到了 ServletConfig 接口对象中。在tomcat调用 init()方法时，首先会将 web.xml 中当前 Servlet 类的配置信息封装为一个对象。这个对象的类型实现了 ServletConfig 接口， Web 容器会将这个对象传递给init()方法中的 ServletConfig 参数。</p>
<p>​    1、Tomcat服务器是一个实现了Servlet规范和JSP规范的容器</p>
<p>​    2、我们不关心ServletConfig接口的具体实现类，我们只关心接口中有哪些可以使用的方法</p>
<p>​    3、ServletConfig是一个Servlet对象的配置信息对象，ServletConfig对象中封装了一个Servlet对象的配置信息。一个Servlet对象对应一个ServletConfig对象</p>
<p>​    4、将init方法上的ServletConfig参数移动到service方法中，因为我们程序员主要编写的方法是service方法，我们在service方法中可能需要使用ServletConfig</p>
<p>​        在init方法中完成：this.config = config;</p>
<p>​        实现getServletConfig方法的目的是给子类使用ServletConfig</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServletConfig config;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="comment">//将局部变量config赋值给实例变量config</span></span><br><span class="line">        <span class="comment">//目的：在service方法中也可以使用config</span></span><br><span class="line">        <span class="comment">//我们写这条语句的目的是把tomcat服务器传过来的config对象变成全局对象供其他方法使用</span></span><br><span class="line">        <span class="keyword">this</span>.config = config;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        <span class="comment">//获取ServletConfig</span></span><br><span class="line">        ServletConfig config = getServletConfig();</span><br><span class="line">        <span class="comment">//通过初始化参数的name获取value</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        String driver = config.getInitParameter(&quot;driver&quot;);</span></span><br><span class="line"><span class="comment">        String url = config.getInitParameter(&quot;url&quot;);</span></span><br><span class="line"><span class="comment">        String user = config.getInitParameter(&quot;user&quot;);</span></span><br><span class="line"><span class="comment">        String password = config.getInitParameter(&quot;password&quot;);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        out.print(driver);</span></span><br><span class="line"><span class="comment">        out.print(&quot;&lt;br&gt;&quot;);</span></span><br><span class="line"><span class="comment">        out.print(url);</span></span><br><span class="line"><span class="comment">        out.print(&quot;&lt;br&gt;&quot;);</span></span><br><span class="line"><span class="comment">        out.print(user);</span></span><br><span class="line"><span class="comment">        out.print(&quot;&lt;br&gt;&quot;);</span></span><br><span class="line"><span class="comment">        out.print(password);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有初始化参数的name</span></span><br><span class="line">        Enumeration&lt;String&gt; names = config.getInitParameterNames();</span><br><span class="line">        <span class="keyword">while</span>(names.hasMoreElements())&#123;</span><br><span class="line">            String name = names.nextElement();</span><br><span class="line">            String value = config.getInitParameter(name);</span><br><span class="line">            out.print(name + <span class="string">&quot;=&quot;</span> + value);</span><br><span class="line">            out.print(<span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//这个方法供子类使用，子类调用此方法获取ServletConfig</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="ServletConfig接口中的那些常用方法："><a href="#ServletConfig接口中的那些常用方法：" class="headerlink" title="ServletConfig接口中的那些常用方法："></a>ServletConfig接口中的那些常用方法：</h5><p>​    String getInitParameter(String name)：通过初始化参数的name获取value</p>
<p>​    Enumeration getInitParameterNames()：获取所有初始化参数的name</p>
<p>​    String getServletName()：获取<servlet-name>servletname</servlet-name></p>
<p>​    ServletContext getServletContext()：获取ServletContext【Servlet上下文】对象</p>
<h4 id="ServletContext接口"><a href="#ServletContext接口" class="headerlink" title="ServletContext接口"></a>ServletContext接口</h4><p>（利用config.getServletContext方法获取）</p>
<p>1、javax.serlvet.ServletContext接口，Servlet规范</p>
<p>2、javaweb程序员只需要面向SerlvetContext接口调用方法即可，不需要关心Tomcat具体的实现</p>
<p>3、SerlvetContext到底是什么？什么时候被创建？什么时候被销毁？创建几个？</p>
<p>​        - 一个webapp只有一个web.xml文件，web.xml文件服务器启动阶段被解析。</p>
<p>​        - 一个webapp只有一个ServletContext对象，ServletContext在服务器启动阶段被实例化。</p>
<p>​        - ServletContext在服务器关闭的时候会被销毁。</p>
<p>​        - ServletContext对应的是web.xml文件，是web.xml文件的代表。</p>
<p>​        - 在同一个webapp中，所有的Servlet对象共享同一个ServletContext对象。</p>
<p>​        - 所有的用户若想共享同一个数据，可以将这个数据放到ServletContext对象中。</p>
<p>​        - 一般放到ServletContext对象中的数据是不建议涉及到修改操作的，它是多线程共享的，存在安全问题</p>
<p>4、SerlvetContext接口中有哪些常用方法？</p>
<ul>
<li><p>Object getAttribute(String name)</p>
</li>
<li><p>void removeAttribute(String name)</p>
</li>
<li><p>void setAttribute(String name，Object object)</p>
</li>
<li><p>String getInitParameter(String name)  ，通过name获取value</p>
</li>
<li><p>Enumeration getInitParameter()  ，获取所有的value</p>
<ul>
<li>String getRealPath(String path)，获取绝对路径</li>
</ul>
</li>
</ul>
<p>5、Serlvet、ServletConfig、ServletContext之间的关系？</p>
<p>​        一个Servlet对应一个ServletConfig对象，100个Servlet对应100个ServletConfig</p>
<p>​        所有的Servlet共享一个ServletContext对象</p>
<h5 id="在web-xml文件中设置欢迎页面"><a href="#在web-xml文件中设置欢迎页面" class="headerlink" title="在web.xml文件中设置欢迎页面"></a>在web.xml文件中设置欢迎页面</h5><p>index.html、 index.htm、 index.jsp都是默认的欢迎页面，系统自动配置过，不需要我们在web.xml中额外配置 </p>
<p>欢迎页面不一定非要是html，可以是jsp，可以是htm，也可以是Servlet，是任何一种web资源即可</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--欢迎页面可以设置多个，越靠上优先级越高--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>login.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>html/welcome.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--优先选择login.html，若此资源不存在，才会选择html/welcome.html--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--路径不需要以&quot;/&quot;开始，只需要从webapp的根目录开始即可--&gt;</span></span><br></pre></td></tr></table></figure>



<h5 id="关于web开发中的错误代码，HTTP状态码404-500"><a href="#关于web开发中的错误代码，HTTP状态码404-500" class="headerlink" title="关于web开发中的错误代码，HTTP状态码404/500"></a>关于web开发中的错误代码，HTTP状态码404/500</h5><p>正确的HTTP协议状态码：200【OK】</p>
<p>404：资源路径有问题</p>
<p>500：服务器内部的错误</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--用web.xml配置统一的错误处理方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">location</span>&gt;</span>error.html<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h5 id="缺省适配器模式Generic"><a href="#缺省适配器模式Generic" class="headerlink" title="缺省适配器模式Generic"></a>缺省适配器模式Generic</h5><p>​    我们目前所有的Servlet类直接实现了javax.servlet.Servlet接口，但是这个接口中有很多方法是目前不需要的，我们可能只需要编写service。直接实现Servlet接口代码丑陋，有必要在中间添加一个适配器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * GenericServlet是一个适配器，这个适配器是一个Servlet</span></span><br><span class="line"><span class="comment"> * 以后javaweb程序员无需直接实现Servlet接口了，去继承这个适配器即可，重写service方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServletConfig config;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.config = servletConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> config;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;&#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//------------------以下方法是扩展方法，方便子类的使用-----------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletContext <span class="title">getServletContext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getServletConfig().getServletContext();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我们不需要自己写一个适配器，因为SUN公司已经写好了一个GenericServlet，我们只需要继承javax.servlet.GenericServlet重写无参数的init和service方法即可。</p>
<h4 id="HTTP协议的详细内容："><a href="#HTTP协议的详细内容：" class="headerlink" title="HTTP协议的详细内容："></a>HTTP协议的详细内容：</h4><p>1.1    什么是HTTP协议？</p>
<ul>
<li>超文本传输协议</li>
<li>浏览器和服务器之间的一种通讯协议</li>
<li>该协议是W3C负责制定的，本质上就是数据传送格式，浏览器和服务器以这种数据格式进行接收和发送</li>
<li>请求和响应</li>
</ul>
<p>1.2    HTTP协议的版本号？</p>
<p>​    HTTP1.1</p>
<p>1.3    请求协议：四部分？</p>
<p>​    请求行</p>
<p>​    消息报头</p>
<p>​    空白行</p>
<p>​    请求体</p>
<p>​    请求行包括：请求方式 URI 协议版本号</p>
<p>​    空白行：专门用来分离消息报头和请求体的</p>
<p>1.4    响应协议：四部分？</p>
<p>​    状态行</p>
<p>​    响应报头</p>
<p>​    空白行</p>
<p>​    响应体</p>
<p>​    状态行：协议版本号HTTP/1.1   状态码200   状态描述信息OK</p>
<p>​    空白行：分离响应报头和响应体</p>
<p>重点掌握状态码：200 响应正常</p>
<p>​                                404 资源未找到</p>
<p>​                                500 服务器内部错误</p>
<h5 id="GET请求和POST请求："><a href="#GET请求和POST请求：" class="headerlink" title="GET请求和POST请求："></a>GET请求和POST请求：</h5><p>什么情况是POST请求？什么情况是GET请求？</p>
<ul>
<li>只有使用表单form且method设置为”post”时才是post，其他情况都是GET方式。</li>
</ul>
<p>GET请求和POST请求的区别？</p>
<ul>
<li><p>GET请求在请求行上提交数据，这种提交方式最终提交的数据会显示到浏览器的地址栏上</p>
</li>
<li><p>POST请求在请求体中提交数据，不会在地址栏上显示</p>
</li>
<li><p>POST请求的数据没有长度限制，GET请求的数据长度有限制</p>
</li>
<li><p>GET请求只能提交字符串数据，POST请求可以提交任何类型的数据，包括视频，所以文件上传必须使用POST请求</p>
</li>
<li><p>GET请求最终的结果会被浏览器缓存收纳。而POST请求的结果不会被缓存</p>
</li>
</ul>
<p>GET请求和POST请求如何选择？</p>
<ul>
<li>有敏感数据，必须POST</li>
<li>不是普通字符串，必须POST</li>
<li>传送的数据非常多，必须POST</li>
<li>请求是为了修改服务器资源，必须POST</li>
</ul>
<p>GET请求，多数是从服务器读取资源，需要被浏览器缓存</p>
<p>POST请求是修改服务器，每次都不一样，不需要被缓存</p>
<h5 id="缓存解决方案"><a href="#缓存解决方案" class="headerlink" title="缓存解决方案"></a>缓存解决方案</h5><p>不想存储GET缓存，在URL最后使用JS的获取毫秒避免路径相同即可</p>
<h5 id="保证前端请求方式和后台程序处理方式一致"><a href="#保证前端请求方式和后台程序处理方式一致" class="headerlink" title="保证前端请求方式和后台程序处理方式一致"></a>保证前端请求方式和后台程序处理方式一致</h5><h5 id="前端的页面发送的请求方式应当和服务器需要的请求方式一样"><a href="#前端的页面发送的请求方式应当和服务器需要的请求方式一样" class="headerlink" title="前端的页面发送的请求方式应当和服务器需要的请求方式一样"></a>前端的页面发送的请求方式应当和服务器需要的请求方式一样</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用if语句判断</span></span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;POST&quot;</span>.equals(method))&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;GET&quot;</span>.equals(method))&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="怎么在javaweb程序中获取请求方式？"><a href="#怎么在javaweb程序中获取请求方式？" class="headerlink" title="怎么在javaweb程序中获取请求方式？"></a>怎么在javaweb程序中获取请求方式？</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先进行类型强转，把ServletRequest变成HttpServletRequest</span></span><br><span class="line">HttpServletRequest request = (HttpServletRequest)req;</span><br><span class="line">HttpServletResponse response = (HttpServletResponse)res;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HttpServletRequest的方法</span></span><br><span class="line">request.getMethod();</span><br></pre></td></tr></table></figure>

<h5 id="将GenericServlet封装成一个HttpServlet，实现doGet和doPost"><a href="#将GenericServlet封装成一个HttpServlet，实现doGet和doPost" class="headerlink" title="将GenericServlet封装成一个HttpServlet，实现doGet和doPost"></a>将GenericServlet封装成一个HttpServlet，实现doGet和doPost</h5><p>get请求重写doGet、post请求重写doPost。doPost和doGet等同看做main方法</p>
<h5 id="模板方法设计模式？"><a href="#模板方法设计模式？" class="headerlink" title="模板方法设计模式？"></a>模板方法设计模式？</h5><p>​    Servlet规范中的：HttpServlet是一个典型的模板方法设计模式</p>
<p>​    HttpServlet是一个模板类，service方法是典型的模板方法，定义了核心算法骨架，doGet、doPost具体的实现步骤延迟到子类中完成</p>
<h4 id="HttpServletRequest接口"><a href="#HttpServletRequest接口" class="headerlink" title="HttpServletRequest接口"></a>HttpServletRequest接口</h4><ul>
<li><p>String getParameter(String name);     //获取value里面的第一个</p>
</li>
<li><p>String[] getParameterValues(String name);    //获取所有的value，适合用来取checkbox里面的数据</p>
</li>
<li><p>Map getParameterMap();    //获取Map</p>
</li>
<li><p>Enumeration getParameterNames();    //获取所有key</p>
</li>
<li><p>Object getAttribute(String name)</p>
</li>
<li><p>void setAttribute(String name,Object o)</p>
</li>
<li><p>void removeAttribute(String name)</p>
<p>同一个请求中存储，在同一个请求不同的Servlet也可以访问存储的Attribute</p>
</li>
</ul>
<ul>
<li><p>RequestDispatcher getRequestDispatcher(String path)     //获取请求转发器</p>
</li>
<li><p>forward(request,response)    //</p>
</li>
<li><p>void setCharacterEncoding(String )      //解决乱码</p>
</li>
</ul>
<h5 id="web程序中乱码的解决方案"><a href="#web程序中乱码的解决方案" class="headerlink" title="web程序中乱码的解决方案"></a>web程序中乱码的解决方案</h5><p>1、乱码出现的位置：</p>
<ul>
<li>数据”传递”</li>
<li>数据”展示”</li>
<li>数据”保存”</li>
</ul>
<p>2、</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java中：response.setContentType(&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">html中：&lt;meta content&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>3、解决传递过程中的乱码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = dname.getBytes(<span class="string">&quot;ISO-8859-1&quot;</span>);  <span class="comment">//解码</span></span><br><span class="line">dname = <span class="keyword">new</span> String(bytes,<span class="string">&quot;UTF-8&quot;</span>);   <span class="comment">//编码【这里的编码方式和浏览器相同】</span></span><br></pre></td></tr></table></figure>





<h5 id="web中资源跳转的方式：转发和重定向"><a href="#web中资源跳转的方式：转发和重定向" class="headerlink" title="web中资源跳转的方式：转发和重定向"></a>web中资源跳转的方式：转发和重定向</h5><p>转发RequestDispatcher   ：一次请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(<span class="string">&quot;/b&quot;</span>).forward(request,response);</span><br></pre></td></tr></table></figure>

<p>重定向sendRedirects    ：两次请求，浏览器会重新发送一次request请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requese.sendRedirect(request.getContextPath() + <span class="string">&quot;/b&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>转发是request对象触发的，重定向是response对象触发的</li>
<li>转发是第一请求，地址栏不会变化</li>
<li>重定向是第二请求，地址栏会变化</li>
</ul>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(String cookieName,String cookieValue);		</span><br></pre></td></tr></table></figure>

<ul>
<li>Cookie 由name和value组成，都是字符串String类型</li>
<li>请求路径和Cookie是相关的，不同的请求路径会发送提交不同的Cookie</li>
</ul>
<ul>
<li>路径是可以指定的，可以将Cookie和某个特定的路径绑定在一起</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cookie.setPath(<span class="string">&quot;URI&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>默认情况下，cookie被保存在浏览器缓存中，通过设置cookie的有效时长可以将cookie保存在硬盘中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cookie1.setMaxAge(<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>);    <span class="comment">//有效期60s*60m*24h=1天</span></span><br></pre></td></tr></table></figure>



<h5 id="javaweb中路径的编写形式"><a href="#javaweb中路径的编写形式" class="headerlink" title="javaweb中路径的编写形式"></a>javaweb中路径的编写形式</h5><h5 id="url-pattern用来给Servlet设置访问路径，可以设置多个，也可以设置多种形式"><a href="#url-pattern用来给Servlet设置访问路径，可以设置多个，也可以设置多种形式" class="headerlink" title="url-pattern用来给Servlet设置访问路径，可以设置多个，也可以设置多种形式"></a>url-pattern用来给Servlet设置访问路径，可以设置多个，也可以设置多种形式</h5><h4 id="HttpSession"><a href="#HttpSession" class="headerlink" title="HttpSession"></a>HttpSession</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HttpSession session = request.getSession();        <span class="comment">//获取session，不存在则新建</span></span><br><span class="line">HttpSession session = request.getSession(<span class="keyword">true</span>);    <span class="comment">//获取session，不存在则新建</span></span><br><span class="line">HttpSession session = request.getSession(<span class="keyword">false</span>);   <span class="comment">//获取session，不存在则返回null</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不止javaweb，只要是web开发都有Session机制</li>
<li>Cookie将会话状态保存在客户端，HttpSession将会话状态保存在服务器端</li>
<li>“打开浏览器到关闭浏览器”表示一次完整会话</li>
</ul>
<h5 id="session的实现原理："><a href="#session的实现原理：" class="headerlink" title="session的实现原理："></a>session的实现原理：</h5><ul>
<li>打开浏览器，在浏览器上发送首次请求</li>
<li>服务器会创建一个HttpSession对象，该对象代表一次会话</li>
<li>同时生成HttpSession对象对应的Cookie对象，并且Cookie对象的name是JSESSIONID、value是32位长度的字符串</li>
<li>服务器将Cookie的value和HttpSession对象绑定到session列表中</li>
<li>服务器将Cookie完整发送给浏览器客户端</li>
<li>浏览器客户端将Cookie保存到缓存中</li>
<li>只要浏览器不关闭，Cookie不会消失</li>
<li>当再次发送请求的时候，会自动提交缓存当中的Cookie</li>
<li>服务器接收到Cookie，验证该Cookie的name确实是：JSESSIONID，然后获取该Cookie的value</li>
<li>通过Cookie的value去session列表中检索对应的HttpSession对象</li>
</ul>
<h5 id="什么是一次会话？本质上的一次会话？"><a href="#什么是一次会话？本质上的一次会话？" class="headerlink" title="什么是一次会话？本质上的一次会话？"></a>什么是一次会话？本质上的一次会话？</h5><ul>
<li>一般多数情况下：用户打开浏览器，在浏览器上进行操作，然后将浏览器关闭，表示一次会话结束</li>
<li>本质上：从session对象的创建到最终session对象超时之后销毁，这个才是真正意义的一次完整会话</li>
</ul>
<h5 id="应用范围applocation、会话范围session、请求范围request"><a href="#应用范围applocation、会话范围session、请求范围request" class="headerlink" title="应用范围applocation、会话范围session、请求范围request"></a>应用范围applocation、会话范围session、请求范围request</h5><p>applocation &gt; session &gt; request</p>
<ul>
<li>application完成跨会话共享数据</li>
<li>session完成跨请求共享数据，请求必须在同一个会话中</li>
<li>request完成跨Servlet共享数据，这些Servlet必须在同一个请求中【转发】</li>
</ul>
<h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><p>JSP就是为了节省out.print(“”);的书写，所以直接将java代码搬到JSP页面中显示</p>
<p>我们把一些数据存入JSP的内置对象中（request、session、application），然后再JSP中提取这些数据进行我们需要的处理操作（写入页面等）</p>
<h5 id="HTML和JSP的区别"><a href="#HTML和JSP的区别" class="headerlink" title="HTML和JSP的区别"></a>HTML和JSP的区别</h5><p>1、作为资源文件类型不同：</p>
<pre><code>HTML文件属于静态资源文件，其相关命令需要在浏览器编译并执行的

JSP文件属于动态资源文件，其相关命令需要在服务端编译并执行的
</code></pre>
<p>2、调用形式不同</p>
<pre><code>如果浏览器访问HTML文件，此时Http服务器直接通过一个输出流将HTML文件中所有的内容写入到响应体

如果浏览器访问JSP文件。此时Http服务器根据JSP规范来操作JSP文件编辑----&gt;编译-----&gt;调用
</code></pre>
<h5 id="JSP内置对象：request"><a href="#JSP内置对象：request" class="headerlink" title="JSP内置对象：request"></a>JSP内置对象：request</h5><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">   JSP文件内置对象: request</span><br><span class="line">             类型：HttpServletRequest</span><br><span class="line">             作用: 在JSP文件运行时读取请求包信息</span><br><span class="line">                  与Servlet在请求转发过程中实现数据共享</span><br><span class="line"></span><br><span class="line">  在浏览器输入以下内容： http:<span class="comment">//localhost:8080/myWeb/request.jsp?userName=allen&amp;password=123，则会将userName和password存入JSP内置的request对象中</span></span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">   <span class="comment">//在JSP文件执行时，借助于内置request对象读取请求包参数信息</span></span><br><span class="line">    String userName = request.getParameter(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">    String password = request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">来访用户姓名:&lt;%=userName%&gt;&lt;br/&gt;</span><br><span class="line">来访用户密码:&lt;%=password%&gt;</span><br></pre></td></tr></table></figure>

<h5 id="JSP内置对象：session"><a href="#JSP内置对象：session" class="headerlink" title="JSP内置对象：session"></a>JSP内置对象：session</h5><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">    JSP文件内置对象:session</span><br><span class="line">              类型:HttpSession</span><br><span class="line">              作用：JSP文件在运行时，可以session指向当前用户私人储物柜，添加</span><br><span class="line">                   共享数据，或则读取共享数据</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--将共享数据添加到当前用户私人储物柜--&gt;</span><br><span class="line">&lt;%</span><br><span class="line">   <span class="comment">// HttpSession session = request.getSession();</span></span><br><span class="line">   session.setAttribute(<span class="string">&quot;key1&quot;</span>, <span class="number">200</span>);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">      session_1.jsp与session_2.jsp为同一个用户/浏览器提供服务。</span><br><span class="line">      因此可以使用当前用户在服务端的私人储物柜进行数据共享</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;%</span><br><span class="line">     Integer value=(Integer)session.getAttribute(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">%&gt;</span><br><span class="line">session_2.jsp从当前用户session中读取数据:&lt;%=value%&gt;</span><br></pre></td></tr></table></figure>

<h5 id="JSP内置对象：application"><a href="#JSP内置对象：application" class="headerlink" title="JSP内置对象：application"></a>JSP内置对象：application</h5><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">       ServletContext application;全局作用域对象</span><br><span class="line">       同一个网站中Servlet与JSP，都可以通过当前网站的全局作用域对象实现数据共享</span><br><span class="line">       JSP文件内置对象 ： application</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    application.setAttribute(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ServletContext application = request.getServletContext();</span><br><span class="line">        String value = (String)application.getAttribute(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;value = &quot;</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Servlet和JSP文件分工"><a href="#Servlet和JSP文件分工" class="headerlink" title="Servlet和JSP文件分工"></a>Servlet和JSP文件分工</h5><p>1、Servlet 与   JSP 分工:</p>
<pre><code>Servlet： 负责处理业务并得到【处理结果】--------------------大厨

JSP：     不负责业务处理，主要任务将Servlet中【处理结果】写入到响应体----传菜员
</code></pre>
<p>2、Servlet 与  JSP 之间调用关系</p>
<p>   Servlet工作完毕后，一般通过请求转发方式 向Tomcat申请调用JSP</p>
<p>3、Servlet  与 JSP 之间如何实现数据共享</p>
<p>   Servlet将处理结果添加到【请求作用域对象】</p>
<p>   JSP文件在运行时从【请求作用域对象】得到处理结果</p>
<h5 id="JSP文件运行原理"><a href="#JSP文件运行原理" class="headerlink" title="JSP文件运行原理"></a>JSP文件运行原理</h5><p>一、Http服务器调用JSP文件步骤:</p>
<pre><code>1.Http服务器将JSP文件内容【编辑】为一个Servlet接口实现类（.java）

2.Http服务器将Servlet接口实现类【编译】为class文件(.class)

3.Http服务器负责创建这个class的实例对象，这个实例对象就是Servlet实例对象

4.Http服务器通过Servlet实例对象调用_jspService方法，将jsp文件内容写入到响应体
</code></pre>
<p>二、Http服务器【编辑】与【编译】JSP文件位置：</p>
<pre><code>标准答案：我在【work】下看到这个证据

C:\Users\[登录windows系统用户角色名]\.IntelliJIdea2018.3\system\tomcat\[网站工作空间]\work\Catalina\localhost\【网站别名】\org\apache\jsp
</code></pre>
<p>三、当一个JSP文件被访问时，Tomcat调用的并不是当前JSP文件,而是JSP文件对应的Servlet接口实现类中_jspService方法。    </p>
<p>_jspService方法负责将开发人员在JSP文件书写的所有内容写入到响应体中</p>
<p>四、</p>
<ul>
<li><p>判断当前请求方式。Jsp文件可以接收的请求方式有POST,GET,HEAD</p>
</li>
<li><p>声明局部变量。这些局部变量都可以在JSP文件开发时直接使用</p>
</li>
<li><p>输出部分。这部分执行时将JSP文件内容通过输出流写入到响应体</p>
</li>
</ul>
<h1 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h1><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">     Integer sid = (Integer)application.getAttribute(<span class="string">&quot;sid&quot;</span>);</span><br><span class="line">     String  sname = (String)session.getAttribute(<span class="string">&quot;sname&quot;</span>);</span><br><span class="line">     String  home = (String)request.getAttribute(<span class="string">&quot;home&quot;</span>);</span><br><span class="line">%&gt;</span><br><span class="line">学员ID:&lt;%=sid%&gt;&lt;br/&gt;</span><br><span class="line">学员姓名:&lt;%=sname%&gt;&lt;br/&gt;</span><br><span class="line">学员地址:&lt;%=home%&gt;</span><br><span class="line"></span><br><span class="line">&lt;hr/&gt;</span><br><span class="line">&lt;!--以下三句是EL表达式--&gt;</span><br><span class="line">学员ID:$&#123;applicationScope.sid&#125;&lt;br/&gt;</span><br><span class="line">学员姓名:$&#123;sessionScope.sname&#125;&lt;br/&gt;</span><br><span class="line">学员地址:$&#123;requestScope.home&#125;</span><br></pre></td></tr></table></figure>

<h5 id="一、EL表达式"><a href="#一、EL表达式" class="headerlink" title="一、EL表达式"></a>一、EL表达式</h5><p> 1.命令格式：${作用域对象别名.共享数据}</p>
<p> 2.命令作用：</p>
<pre><code>1）EL表达式是EL工具包提供一种特殊命令格式【表达式命令格式】

2）EL表达式在JSP文件上使用

3）负责在JSP文件上从作用域对象读取指定的共享数据并输出到响应体
</code></pre>
<h5 id="二、EL表达式——作用域对象别名"><a href="#二、EL表达式——作用域对象别名" class="headerlink" title="二、EL表达式——作用域对象别名"></a>二、EL表达式——作用域对象别名</h5><p>1.JSP文件可以使用的作用域对象</p>
<pre><code>1) ServletContext  application:全局作用域对象

2) HttpSession  session:会话作用域对象

3) HttpServletRequest  request:请求作用域对象

4) PageContext  pageContext:当前页作用域对象，这是JSP文件独有的作用域对象。Servlet中不存在。
</code></pre>
<p>在当前页作用域对象存放的共享数据仅能在当前JSP文件中使用，不能共享给其他Servlet或其他JSP文件。<br>    真实开发过程，主要用于JSTL标签与JSP文件之间数据共享<br>              数据<br>    JSTL———–&gt;pageContext———–&gt;JSP</p>
<p>2.EL表达式提供作用域对象别名</p>
<pre><code> JSP                       EL表达式
</code></pre>
<p>application            ${applicationScope.共享数据名}</p>
<p>session                   ${sessionScope.共享数据名}</p>
<p>request                  ${requestScope.共享数据名}</p>
<p>pageContext          ${pageScope.共享数据名}</p>
<h5 id="三、EL表达式将引用对象属性写入到响应体"><a href="#三、EL表达式将引用对象属性写入到响应体" class="headerlink" title="三、EL表达式将引用对象属性写入到响应体"></a>三、EL表达式将引用对象属性写入到响应体</h5><p> 1.命令格式：${作用域对象别名.共享数据名.属性名}</p>
<p> 2.命令作用：从作用域对象读取指定共享数据关联的引用对象的属性值，并自动将属性的结果写入到响应体</p>
<p> 3.属性名： 一定要与引用类型属性名大小写完全一致</p>
<p> 4.EL表达式没有提供遍历集合方法，因此无法从作用域对象读取集合内容输出</p>
<h5 id="四、EL表达式简化版"><a href="#四、EL表达式简化版" class="headerlink" title="四、EL表达式简化版"></a>四、EL表达式简化版</h5><p> 1.命令格式： ${共享数据名}</p>
<p> 2.命令作用： EL表达式允许开发人员开发时省略作用域对象别名</p>
<p> 3.工作原理：<br>              EL表达式简化版由于没有指定作用域对象，所以在执行时采用【猜】算法。【从小猜到大】</p>
<pre><code>  首先到【pageContext】定位共享数据，如果存在直接读取输出并结束执行
  如果在【pageContext】没有定位成功，到【request】定位共享数据，如果存在直接读取输出并结束执行
  如果在【request】没有定位成功，到【session】定位共享数据，如果存在直接读取输出并结束执行
  如果在【session】没有定位成功，到【application】定位共享数据，如果存在直接读取输出并结束执行
  如果在【application】没有定位成功，返回null

  pageContext---&gt;request---&gt;session---&gt;application
</code></pre>
<p> 4.存在隐患：</p>
<pre><code>    容易降低程序执行速度【南辕北辙】
    容易导致数据定位错误
</code></pre>
<p> 5.应用场景：<br>        设计目的，就是简化从pageContext读取共享数据并输出难度</p>
<p> 6.EL表达式简化版尽管存在很多隐患，但是在实际开发过程中，开发人员为了节省时间，一般都使用<br>   简化版，拒绝使用标准版</p>
<h5 id="五、EL表达式—–支持运算表达式"><a href="#五、EL表达式—–支持运算表达式" class="headerlink" title="五、EL表达式—–支持运算表达式"></a>五、EL表达式—–支持运算表达式</h5><p> 1.前提：在JSP文件有时需要将读取共享数据进行一番运算之后，将运算结果写入到响应体</p>
<p> 2.运算表达式:</p>
<pre><code>    1) 数学运算

    2) 关系运算:  &gt;   &gt;=   ==   &lt;   &lt;=   !=

                           gt   ge   eq   lt   le   !=               【gt = greater than     lt = less than】

    3)逻辑运算：  &amp;&amp;   ||    ！
</code></pre>
<h5 id="六、EL表达式提供内置对象【用得少，一般都在Servlet中使用】"><a href="#六、EL表达式提供内置对象【用得少，一般都在Servlet中使用】" class="headerlink" title="六、EL表达式提供内置对象【用得少，一般都在Servlet中使用】"></a>六、EL表达式提供内置对象【用得少，一般都在Servlet中使用】</h5><pre><code>1.命令格式：$&#123;param.请求参数名&#125;

2.命令作用：通过请求对象读取当前请求包中请求参数内容，并将请求参数内容写入到响应体

3.代替命令：index.jsp
</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">发送请求：http:&#x2F;&#x2F;localhost:8080&#x2F;myWeb&#x2F;index_1.jsp?userName&#x3D;mike&amp;password&#x3D;123</span><br><span class="line"></span><br><span class="line">来访者姓名:$&#123;param.userName&#125;&lt;br&#x2F;&gt;</span><br><span class="line">来访者密码:$&#123;param.password&#125;</span><br></pre></td></tr></table></figure>

<pre><code>  1.命令格式：$&#123;paramValues.请求参数名[下标]&#125;
  
  2.命令作用：如果浏览器发送的请求参数是[一个请求参数关联多个值]，此时可以通过paramVaues读取请求参数下指定位置的值，并写入到响应体
  
  3.代替命令：此时pageNo请求参数在请求包以数组形式存在，pageNo:[1,2,3]
</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">发送请求：http:&#x2F;&#x2F;localhost:8080&#x2F;myWeb&#x2F;index_2.jsp?deptNo&#x3D;10&amp;deptNo&#x3D;20&amp;deptNo&#x3D;30</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第一个部门编号:$&#123;paramValues.deptNo[0]&#125;&lt;br&#x2F;&gt;</span><br><span class="line">第二个部门编号:$&#123;paramValues.deptNo[1]&#125;&lt;br&#x2F;&gt;</span><br><span class="line">第三个部门编号:$&#123;paramValues.deptNo[2]&#125;&lt;br&#x2F;&gt;</span><br></pre></td></tr></table></figure>



<h5 id="七、EL表达式中出现的常见异常"><a href="#七、EL表达式中出现的常见异常" class="headerlink" title="七、EL表达式中出现的常见异常:"></a>七、EL表达式中出现的常见异常:</h5><pre><code> javax.el.PropertyNotFoundException:在对象中没有找到指定属性【sname属性写成了name属性就会报这个错】
</code></pre>
<h5 id="八、EL表达式禁用"><a href="#八、EL表达式禁用" class="headerlink" title="八、EL表达式禁用"></a>八、EL表达式禁用</h5><p>在当前JSP文件中禁用EL表达式</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page isELIgnored=<span class="string">&quot;true&quot;</span> %&gt; 表示是否禁用EL语言。TRUE表示禁止；FALSE表示不禁止</span><br></pre></td></tr></table></figure>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/03/14/Mybatis+Spring+SpringMVC/" rel="next" title="">
                <i class="fa fa-chevron-left"></i> 
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95java/" rel="prev" title="">
                 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%92%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">互联网通信流程介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%9B%E3%80%82%E6%B6%89%E5%8F%8A%E6%8A%80%E6%9C%AF%E3%80%90%E8%80%81%E6%97%A7%E3%80%91"><span class="nav-number">1.0.0.0.1.</span> <span class="nav-text">四。涉及技术【老旧】</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%94%E3%80%82%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%92%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1"><span class="nav-number">1.0.0.0.2.</span> <span class="nav-text">五。什么是互联网通信</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%AD%E3%80%82%E4%BA%92%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B%E8%A7%92%E8%89%B2%E5%88%92%E5%88%86"><span class="nav-number">1.0.0.0.3.</span> <span class="nav-text">六。互联网通信过程角色划分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%83%E3%80%82%E4%BA%92%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.0.0.0.4.</span> <span class="nav-text">七。互联网通信模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%AB%E3%80%82%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%EF%BC%9A"><span class="nav-number">1.0.0.0.5.</span> <span class="nav-text">八。共享资源文件：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B9%9D%E3%80%82%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%9C%A8%E4%BA%92%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E6%8B%85%E8%B4%9F%E8%81%8C%E8%B4%A3"><span class="nav-number">1.0.0.0.6.</span> <span class="nav-text">九。开发人员在互联网通信流程担负职责:</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Http%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%8C%85"><span class="nav-number">1.1.</span> <span class="nav-text">Http网络协议包</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E3%80%82%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%8C%85%EF%BC%9A"><span class="nav-number">1.1.0.0.1.</span> <span class="nav-text">一。网络协议包：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E3%80%82%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%EF%BC%9A"><span class="nav-number">1.1.0.0.2.</span> <span class="nav-text">二。常见网络协议：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%89%E3%80%82Http%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%8C%85%EF%BC%9A"><span class="nav-number">1.1.0.0.3.</span> <span class="nav-text">三。Http网络协议包：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%9B%E3%80%82Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%8C%85%E4%B8%8EHttp%E5%93%8D%E5%BA%94%E5%8D%8F%E8%AE%AE%E5%8C%85%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.1.0.0.4.</span> <span class="nav-text">四。Http请求协议包与Http响应协议包介绍:</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%94%E3%80%82Http%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE%E5%8C%85%E5%86%85%E9%83%A8%E7%A9%BA%E9%97%B4%EF%BC%9A%E3%80%90%E8%83%8C%E3%80%91"><span class="nav-number">1.1.0.0.5.</span> <span class="nav-text">五。Http请求协议包内部空间：【背】</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%AD%E3%80%82Http%E5%93%8D%E5%BA%94%E5%8D%8F%E8%AE%AE%E5%8C%85%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84-%E3%80%90%E8%83%8C%E3%80%91"><span class="nav-number">1.1.0.0.6.</span> <span class="nav-text">六。Http响应协议包内部结构 【背】</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Servlet%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%B0%8F%E7%A8%8B%E5%BA%8F-serv-let"><span class="nav-number">2.</span> <span class="nav-text">Servlet：服务器端小程序 serv+let</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaSE%E5%92%8CJavaEE%EF%BC%9F"><span class="nav-number">2.0.1.</span> <span class="nav-text">JavaSE和JavaEE？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFAPI%EF%BC%9F%E5%8C%85%E6%8B%AC%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">2.0.1.0.1.</span> <span class="nav-text">1、什么是API？包括什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFJAVASE%EF%BC%9F"><span class="nav-number">2.0.1.0.2.</span> <span class="nav-text">2、什么是JAVASE？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81JavaSE%E7%9A%84%E6%BA%90%E7%A0%81%E3%80%81%E5%AD%97%E8%8A%82%E7%A0%81%E3%80%81%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3%E5%9C%A8%E5%93%AA%EF%BC%9F"><span class="nav-number">2.0.1.0.3.</span> <span class="nav-text">3、JavaSE的源码、字节码、帮助文档在哪？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFJAVAEE%EF%BC%9F"><span class="nav-number">2.0.1.0.4.</span> <span class="nav-text">4、什么是JAVAEE？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81JAVAEE%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%B7%EF%BC%9F"><span class="nav-number">2.0.1.0.5.</span> <span class="nav-text">5、JAVAEE的版本号？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Servlet%EF%BC%9A"><span class="nav-number">2.0.2.</span> <span class="nav-text">Servlet：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%AC%E8%B4%A8%EF%BC%9A"><span class="nav-number">2.0.2.0.1.</span> <span class="nav-text">本质：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B8%A6%E6%9C%89Servlet%E7%9A%84WebApp%EF%BC%8CFirstServletWebApp%EF%BC%9A"><span class="nav-number">2.0.2.0.2.</span> <span class="nav-text">第一个带有Servlet的WebApp，FirstServletWebApp：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%86%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%EF%BC%8CPrintToBrowser%EF%BC%9A"><span class="nav-number">2.0.2.0.3.</span> <span class="nav-text">将响应结果输出到浏览器中，PrintToBrowser：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E5%93%8D%E5%BA%94%E6%97%B6%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="nav-number">2.0.2.0.4.</span> <span class="nav-text">解决响应时中文乱码问题：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Servlet%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">2.0.2.0.5.</span> <span class="nav-text">Servlet对象生命周期</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#UML%EF%BC%88%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80%EF%BC%89%EF%BC%9A%E5%8F%8D%E5%BA%94%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">2.0.2.0.6.</span> <span class="nav-text">UML（统一建模语言）：反应一个对象的生命周期</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ServletConfig%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.0.2.1.</span> <span class="nav-text">ServletConfig接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ServletConfig%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="nav-number">2.0.2.1.1.</span> <span class="nav-text">ServletConfig接口中的那些常用方法：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ServletContext%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.0.2.2.</span> <span class="nav-text">ServletContext接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8web-xml%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AE%BE%E7%BD%AE%E6%AC%A2%E8%BF%8E%E9%A1%B5%E9%9D%A2"><span class="nav-number">2.0.2.2.1.</span> <span class="nav-text">在web.xml文件中设置欢迎页面</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E4%BA%8Eweb%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81%EF%BC%8CHTTP%E7%8A%B6%E6%80%81%E7%A0%81404-500"><span class="nav-number">2.0.2.2.2.</span> <span class="nav-text">关于web开发中的错误代码，HTTP状态码404&#x2F;500</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%BA%E7%9C%81%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8FGeneric"><span class="nav-number">2.0.2.2.3.</span> <span class="nav-text">缺省适配器模式Generic</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%AF%A6%E7%BB%86%E5%86%85%E5%AE%B9%EF%BC%9A"><span class="nav-number">2.0.2.3.</span> <span class="nav-text">HTTP协议的详细内容：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#GET%E8%AF%B7%E6%B1%82%E5%92%8CPOST%E8%AF%B7%E6%B1%82%EF%BC%9A"><span class="nav-number">2.0.2.3.1.</span> <span class="nav-text">GET请求和POST请求：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">2.0.2.3.2.</span> <span class="nav-text">缓存解决方案</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%9D%E8%AF%81%E5%89%8D%E7%AB%AF%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E5%92%8C%E5%90%8E%E5%8F%B0%E7%A8%8B%E5%BA%8F%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E4%B8%80%E8%87%B4"><span class="nav-number">2.0.2.3.3.</span> <span class="nav-text">保证前端请求方式和后台程序处理方式一致</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%8F%91%E9%80%81%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E5%BA%94%E5%BD%93%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9C%80%E8%A6%81%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E4%B8%80%E6%A0%B7"><span class="nav-number">2.0.2.3.4.</span> <span class="nav-text">前端的页面发送的请求方式应当和服务器需要的请求方式一样</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E5%9C%A8javaweb%E7%A8%8B%E5%BA%8F%E4%B8%AD%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">2.0.2.3.5.</span> <span class="nav-text">怎么在javaweb程序中获取请求方式？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%86GenericServlet%E5%B0%81%E8%A3%85%E6%88%90%E4%B8%80%E4%B8%AAHttpServlet%EF%BC%8C%E5%AE%9E%E7%8E%B0doGet%E5%92%8CdoPost"><span class="nav-number">2.0.2.3.6.</span> <span class="nav-text">将GenericServlet封装成一个HttpServlet，实现doGet和doPost</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-number">2.0.2.3.7.</span> <span class="nav-text">模板方法设计模式？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HttpServletRequest%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.0.2.4.</span> <span class="nav-text">HttpServletRequest接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#web%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%B9%B1%E7%A0%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">2.0.2.4.1.</span> <span class="nav-text">web程序中乱码的解决方案</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#web%E4%B8%AD%E8%B5%84%E6%BA%90%E8%B7%B3%E8%BD%AC%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9A%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">2.0.2.4.2.</span> <span class="nav-text">web中资源跳转的方式：转发和重定向</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cookie"><span class="nav-number">2.0.2.5.</span> <span class="nav-text">Cookie</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#javaweb%E4%B8%AD%E8%B7%AF%E5%BE%84%E7%9A%84%E7%BC%96%E5%86%99%E5%BD%A2%E5%BC%8F"><span class="nav-number">2.0.2.5.1.</span> <span class="nav-text">javaweb中路径的编写形式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#url-pattern%E7%94%A8%E6%9D%A5%E7%BB%99Servlet%E8%AE%BE%E7%BD%AE%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%AE%BE%E7%BD%AE%E5%A4%9A%E4%B8%AA%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E8%AE%BE%E7%BD%AE%E5%A4%9A%E7%A7%8D%E5%BD%A2%E5%BC%8F"><span class="nav-number">2.0.2.5.2.</span> <span class="nav-text">url-pattern用来给Servlet设置访问路径，可以设置多个，也可以设置多种形式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HttpSession"><span class="nav-number">2.0.2.6.</span> <span class="nav-text">HttpSession</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#session%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="nav-number">2.0.2.6.1.</span> <span class="nav-text">session的实现原理：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E6%AC%A1%E4%BC%9A%E8%AF%9D%EF%BC%9F%E6%9C%AC%E8%B4%A8%E4%B8%8A%E7%9A%84%E4%B8%80%E6%AC%A1%E4%BC%9A%E8%AF%9D%EF%BC%9F"><span class="nav-number">2.0.2.6.2.</span> <span class="nav-text">什么是一次会话？本质上的一次会话？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E8%8C%83%E5%9B%B4applocation%E3%80%81%E4%BC%9A%E8%AF%9D%E8%8C%83%E5%9B%B4session%E3%80%81%E8%AF%B7%E6%B1%82%E8%8C%83%E5%9B%B4request"><span class="nav-number">2.0.2.6.3.</span> <span class="nav-text">应用范围applocation、会话范围session、请求范围request</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JSP"><span class="nav-number">3.</span> <span class="nav-text">JSP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#HTML%E5%92%8CJSP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.0.0.0.1.</span> <span class="nav-text">HTML和JSP的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JSP%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%EF%BC%9Arequest"><span class="nav-number">3.0.0.0.2.</span> <span class="nav-text">JSP内置对象：request</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JSP%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%EF%BC%9Asession"><span class="nav-number">3.0.0.0.3.</span> <span class="nav-text">JSP内置对象：session</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JSP%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%EF%BC%9Aapplication"><span class="nav-number">3.0.0.0.4.</span> <span class="nav-text">JSP内置对象：application</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Servlet%E5%92%8CJSP%E6%96%87%E4%BB%B6%E5%88%86%E5%B7%A5"><span class="nav-number">3.0.0.0.5.</span> <span class="nav-text">Servlet和JSP文件分工</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JSP%E6%96%87%E4%BB%B6%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="nav-number">3.0.0.0.6.</span> <span class="nav-text">JSP文件运行原理</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#EL%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.</span> <span class="nav-text">EL表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E3%80%81EL%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.0.0.0.1.</span> <span class="nav-text">一、EL表达式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E3%80%81EL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E2%80%94%E2%80%94%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%AF%B9%E8%B1%A1%E5%88%AB%E5%90%8D"><span class="nav-number">4.0.0.0.2.</span> <span class="nav-text">二、EL表达式——作用域对象别名</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%89%E3%80%81EL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B0%86%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E5%86%99%E5%85%A5%E5%88%B0%E5%93%8D%E5%BA%94%E4%BD%93"><span class="nav-number">4.0.0.0.3.</span> <span class="nav-text">三、EL表达式将引用对象属性写入到响应体</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%9B%E3%80%81EL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%80%E5%8C%96%E7%89%88"><span class="nav-number">4.0.0.0.4.</span> <span class="nav-text">四、EL表达式简化版</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%94%E3%80%81EL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E2%80%94%E2%80%93%E6%94%AF%E6%8C%81%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.0.0.0.5.</span> <span class="nav-text">五、EL表达式—–支持运算表达式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%AD%E3%80%81EL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%8F%90%E4%BE%9B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E3%80%90%E7%94%A8%E5%BE%97%E5%B0%91%EF%BC%8C%E4%B8%80%E8%88%AC%E9%83%BD%E5%9C%A8Servlet%E4%B8%AD%E4%BD%BF%E7%94%A8%E3%80%91"><span class="nav-number">4.0.0.0.6.</span> <span class="nav-text">六、EL表达式提供内置对象【用得少，一般都在Servlet中使用】</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%83%E3%80%81EL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8"><span class="nav-number">4.0.0.0.7.</span> <span class="nav-text">七、EL表达式中出现的常见异常:</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%AB%E3%80%81EL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%A6%81%E7%94%A8"><span class="nav-number">4.0.0.0.8.</span> <span class="nav-text">八、EL表达式禁用</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZYK</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
